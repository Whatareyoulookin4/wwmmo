syntax = "proto2";

package au.com.codeka.warworlds.common.proto;

// https://github.com/square/wire/issues/1325 We need to swap these when switching between Win/Linux
import "au\\com\\codeka\\warworlds\\common\\proto\\common.proto";
import "au\\com\\codeka\\warworlds\\common\\proto\\design.proto";
import "au\\com\\codeka\\warworlds\\common\\proto\\colony.proto";
import "au\\com\\codeka\\warworlds\\common\\proto\\fleet.proto";

//
// Represents a "sector" of space, containing a number of stars and whatnot.
//
message Sector {
  // these are the (x,y) coordinates of the sector. (0,0) is the "centre" of the universe,
  // (1,1) is one sector up and to the right, and so on.
  required int64 x = 1;
  required int64 y = 2;

  // number of colonies in this sector
  required int32 num_colonies = 5;

  // the collection of stars in this sector.
  repeated Star stars = 3;

  // the state of this sector, see SectorsStore.SectorState for possible values.
  required int32 state = 4;
}

message SectorCoord {
  required int64 x = 1;
  required int64 y = 2;
}

// An array of (x,y) coordinates. This is used to store the list of empty sectors, as well
// as a list of "to-be-generated" sectors.
message SectorCoordArray {
  repeated SectorCoord coords = 1;
}

//
// Represents a single star within a sector. The star can have a few planets, though this
// is optional (we don't always return the list of planets with a star).
//
message Star {
  // the identifier of the star, unique throughout the universe.
  required int64 id = 1;

  // the sector this star is contained within
  required int64 sector_x = 11;
  required int64 sector_y = 12;

  // the name of the star
  required string name = 2;

  // the classification of this star. The order of these enum values
  // must correspond to the order of the StarTypes defined in sector.py
  enum Classification {
    BLUE = 0;
    WHITE = 1;
    YELLOW = 2;
    ORANGE = 3;
    RED = 4;
    NEUTRON = 5;
    BLACKHOLE = 6;
    MARKER = 7;
    WORMHOLE = 8;
  }
  required Classification classification = 3;

  // the apparent "size" of the star (which is really just a display thing)
  required int32 size = 5;

  // the offset from the left edge of the sector, in pixels
  required int32 offset_x = 6;

  // the offset from the bottom edge of the sector, in pixels
  required int32 offset_y = 7;

  // the collection of planets orbiting this star (may be empty, for example in the list
  // of stars in a sector)
  repeated Planet planets = 9;

  // collection of EmpireStorages details the presences of the empire(s) in this solar system.
  repeated EmpireStorage empire_stores = 14;

  // List of fleets located in this star
  repeated Fleet fleets = 16;

  // This is the time (in seconds since Unix epoch) since this star "became" empty -- that is,
  // after the colony was destroyed. This only has meaning if the star has no colonies currently.
  optional int64 time_emptied = 17;

  // Time, that this star was last simulated
  optional int64 last_simulation = 18;

  // Time that this star should be simulated again (e.g. to make sure a build is completed or a
  // fleet arrives, etc).
  optional int64 next_simulation = 19;

  // These are extra details stored with the star that define the properties needed by wormholes.
  message Wormhole {
    optional int64 dest_star_id = 1;
    optional int64 tune_complete_time = 2;
    repeated int64 tune_history = 3;
    required int64 empire_id = 4;
  }
  optional Wormhole wormhole = 20;

  // A list of the recent CombatReports, detailing combat on this star.
  repeated CombatReport combat_reports = 21;

  // We store one scout report per empire. Any new scouts that land will overwrite the previous
  // report for that empire. When sending to the client, this will contain only that empire's
  // scout report.
  // In general, we expect only one or two empires to scout any given star, so it's not a bit deal
  // to save the report with the stars themselves.
  repeated ScoutReport scout_reports = 22;
}

// A CombatReport is used to detail the results of combat. Combat occurs when an opposing fleet
// arrives at a star. We keep at most 10 combat reports per star (after a while, they don't really
// matter any more).
message CombatReport {
  // The time the combat happened.
  optional int64 time = 1;

  // The list of fleets that existed before the combat began.
  repeated Fleet fleets_before = 2;

  // The list of fleets that remained after the combat completed.
  repeated Fleet fleets_after = 3;
}

// A ScoutReport is generated by a scout that comes to this star. The report exists forever, even
// if the scout is destroyed. A star will have exactly zero or one scout report per empire.
message ScoutReport {
  // The ID of the star this report is for.
  required int64 star_id = 1;

  // The ID of the empire this report is for.
  required int64 empire_id = 2;

  // The date/time this report was generated.
  required int64 report_time = 3;

  // A snapshot of the bits of the star we care about, at the time this report was generated.
  repeated Fleet fleets = 4;
  repeated Planet planets = 5;
}

// Represents a planet in the star system. A planet orbits a Star which in turn belongs
// to a Sector.
message Planet {
  // The "index" of the planet represents how far it is from the sun. Planets are always
  // in monotonically increasing order of distance (0, 1, 2, 3, etc)
  required int32 index = 2;

  // The various different "kinds" of planets. Planets are spawned in increasing order
  // of probability (so "terran" is most likely, "gas giant" least likely).
  enum Type {
    GASGIANT = 1;
    RADIATED = 2;
    INFERNO = 3;
    ASTEROIDS = 4;
    WATER = 5;
    TOXIC = 6;
    DESERT = 7;
    SWAMP = 8;
    TERRAN = 9;
  }
  required Type planet_type = 3;

  // How "congenial" is this planet to supporting population
  required int32 population_congeniality = 4;

  // How "congenial" is this planet to supporting farming
  required int32 farming_congeniality = 5;

  // How "congenial" is this planet to supporting mining
  required int32 mining_congeniality = 6;

  // How "congenial" is this planet to the production of energy?
  required int32 energy_congeniality = 7;

  // Colony on this planet (if there is one).
  optional Colony colony = 8;
}

// Represents the details of an empire's stored goods in a star. For example, keeps track of stored
// food, energy, minerals, etc, etc.
message EmpireStorage {
  required int64 empire_id = 1;

  required float total_goods = 2;
  required float total_minerals = 3;
  required float total_energy = 4;

  optional float goods_delta_per_hour = 5;
  optional float minerals_delta_per_hour = 6;
  optional float energy_delta_per_hour = 7;

  required float max_goods = 8;
  required float max_minerals = 9;
  required float max_energy = 10;

  optional int64 goods_zero_time = 11;
}

// Every edit to a star is performed as an atomic modification. Colonizing a planet, adjusting focus
// of a colony, etc. This is to ensure edits happen in a deterministic fashion and we can control
// the locking and synchronization better.
message StarModification {
  enum Type {
    // Do not use.
    UNKNOWN_TYPE = 0;

    // Colonize a planet on the star.
    // empire_id and planet_index are required.
    COLONIZE = 1;

    // Adjust a colony's focus.
    // empire_id, colony_id and focus are required.
    ADJUST_FOCUS = 2;

    // Create a new fleet, ignored if sent from client.
    // empire_id and either (design_type and count) or (fleet) are required. If fleet is specified,
    // the new fleet will be a copy of the given fleet. If full_fuel is specified, the new fleet
    // will be given a full fuel tank at no cost to energy storage.
    CREATE_FLEET = 3;

    // Add a build request, start building it.
    // empire_id, colony_id, design_type are required.
    // count is required for ship builds.
    // building_id is required to upgrade a building (rather than build a new one).
    ADD_BUILD_REQUEST = 4;

    // Create a new building, ignored if sent from client.
    // empire_id, colony_id, design_type are required.
    CREATE_BUILDING = 5;

    // Split a fleet in two. In this case, count refers to the number of ships to take out and
    // create a new fleet with. The remaining ships will stay in this fleet.
    // empire_id, fleet_id and count are required.
    SPLIT_FLEET = 6;

    // Merge two or more fleets into one. If any fleets have upgrades, then the upgrade will be kept
    // only if ALL fleets have the upgrade.
    // empire_id, fleet_id and additional_fleet_ids are required.
    MERGE_FLEET = 7;

    // Begin a "fleet move" to a new star. The move will take time, at which point the server will
    // issue a MOVE_FLEET_COMPLETE modification to complete the operation.
    // empire_id, fleet_id, star_id (with the target star) are required.
    MOVE_FLEET = 8;

    // Delete an in-progress build request.
    // empire_id and build_request_id are required.
    DELETE_BUILD_REQUEST = 9;

    // Remove all native colonies and fleets. Useful when a new player joins. Ignored if send from
    // the client.
    // No fields are required.
    EMPTY_NATIVE = 10;

    // Upgrades an existing building.
    // empire_id, colony_id and building_id are required.
    UPGRADE_BUILDING = 11;

    // Attack a colony. This will remove troop carrier ships and remove population from the colony
    // on the planet. If there's more troop carriers than population, we'll remove the colony.
    // empire_id and colony_id are required.
    ATTACK_COLONY = 12;
  }
  required Type type = 1;

  optional int64 empire_id = 2;
  optional int32 planet_index = 3;
  optional int64 colony_id = 4;
  optional int64 fleet_id = 5;
  optional int64 build_request_id = 12;
  optional int64 building_id = 13;

  optional ColonyFocus focus = 6;
  optional Design.DesignType design_type = 7;
  optional int32 count = 8;
  optional int64 star_id = 9;
  optional Fleet fleet = 10;
  repeated int64 additional_fleet_ids = 11;
  optional bool full_fuel = 14;
}
