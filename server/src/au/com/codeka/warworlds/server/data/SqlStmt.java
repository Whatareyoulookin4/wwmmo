package au.com.codeka.warworlds.server.data;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.sql.Types;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Locale;
import java.util.TimeZone;
import java.util.concurrent.TimeUnit;

import org.joda.time.ReadableInstant;

import au.com.codeka.common.Log;

/**
 * This is a wrapper around a \c PreparedStatement, for ease-of-use.
 */
public class SqlStmt implements AutoCloseable {
  private static final Log log = new Log("SqlStmt");
  private static Calendar sUTC;

  private static boolean DBG = false;

  // If the statement takes longer than this amount of  time to execute, log the statement at
  // warning level.
  private static final long LOG_IF_LONGER_TIME_NANOS = TimeUnit.SECONDS.toNanos(1);

  static {
    sUTC = Calendar.getInstance(TimeZone.getTimeZone("UTC"));
  }

  private final Connection conn;
  private final PreparedStatement stmt;
  private final boolean autoCloseConnection;
  private final String sql;
  private final ArrayList<Object> parameters = new ArrayList<>();
  private final ArrayList<SqlResult> results = new ArrayList<>();
  private final long statementStartTimeNanos;
  private boolean wasStatementLogged = false;

  public SqlStmt(Connection conn, String sql, PreparedStatement stmt,
                 boolean autoCloseConnection) {
    this.conn = conn;
    this.stmt = stmt;
    this.sql = sql;
    this.autoCloseConnection = autoCloseConnection;
    statementStartTimeNanos = System.nanoTime();
  }

  public void setInt(int position, int value) throws SQLException {
    wasStatementLogged = false;
    stmt.setInt(position, value);
    saveParameter(position, value);
  }

  public void setInt(int position, Integer value) throws SQLException {
    wasStatementLogged = false;
    if (value == null) {
      setNull(position);
    } else {
      stmt.setInt(position, value);
      saveParameter(position, value);
    }
  }

  public void setLong(int position, long value) throws SQLException {
    wasStatementLogged = false;
    stmt.setLong(position, value);
    saveParameter(position, value);
  }

  public void setLong(int position, Long value) throws SQLException {
    wasStatementLogged = false;
    if (value == null) {
      setNull(position);
    } else {
      stmt.setLong(position, value);
      saveParameter(position, value);
    }
  }

  public void setDouble(int position, double value) throws SQLException {
    wasStatementLogged = false;
    stmt.setDouble(position, value);
    saveParameter(position, value);
  }

  public void setDouble(int position, Double value) throws SQLException {
    wasStatementLogged = false;
    if (value == null) {
      setNull(position);
    } else {
      stmt.setDouble(position, value);
      saveParameter(position, value);
    }
  }

  public void setString(int position, String value) throws SQLException {
    wasStatementLogged = false;
    if (value == null) {
      setNull(position);
    } else {
      stmt.setString(position, value);
      saveParameter(position, value);
    }
  }

  public void setDateTime(int position, ReadableInstant value) throws SQLException {
    wasStatementLogged = false;
    if (value == null) {
      setNull(position);
    } else {
      stmt.setTimestamp(position, new Timestamp(value.getMillis()), sUTC);
      saveParameter(position, value);
    }
  }

  public void setBytes(int position, byte[] bytes) throws SQLException {
    wasStatementLogged = false;
    if (bytes == null) {
      setNull(position);
    } else {
      stmt.setBytes(position, bytes);
      saveParameter(position, String.format(Locale.US, "<BLOB> %d bytes", bytes.length));
    }
  }

  public void setNull(int position) throws SQLException {
    wasStatementLogged = false;
    stmt.setNull(position, Types.NULL);
    saveParameter(position, "<NULL>");
  }

  private void saveParameter(int position, Object value) {
    wasStatementLogged = false;
    int index = position - 1;
    while (parameters.size() < position) {
      parameters.add(null);
    }
    parameters.set(index, value);
  }

  /**
   * Execute an 'update' query. That is, anything but "SELECT".
   */
  public int update() throws SQLException {
    try {
      return stmt.executeUpdate();
    } finally {
      logStatement("update");
    }
  }

  public int getAutoGeneratedID() throws SQLException {
    ResultSet rs = null;
    try {
      rs = stmt.getGeneratedKeys();
      if (rs.next()) {
        return rs.getInt(1);
      }
    } finally {
      if (rs != null) {
        rs.close();
      }
    }

    throw new SQLException("No auto-generated ID available.");
  }

  @SuppressWarnings("unchecked")
  public <T> T selectFirstValue(Class<T> type) throws SQLException {
    ResultSet rs = null;
    try {
      rs = stmt.executeQuery();
      if (rs.next()) {
        return (T) rs.getObject(1);
      }
      return null;
    } finally {
      if (rs != null) rs.close();

      logStatement("selectFirstValue");
    }
  }

  public SqlResult select() throws SQLException {
    try {
      SqlResult result = new SqlResult(stmt.executeQuery());
      results.add(result);
      return result;
    } finally {
      logStatement("select");
    }
  }

  /**
   * Wrapper for executing a single "UPDATE ; SELECT" combo, which is somewhat common.
   * <p>
   * Returns the {@link ResultSet} from the SELECT statement.
   */
  public SqlResult updateAndSelect() throws SQLException {
    try {
      stmt.execute();

      SqlResult res = new SqlResult(stmt.getResultSet());
      results.add(res);
      return res;
    } finally {
      logStatement("updateAndSelect");
    }
  }

  private void logStatement(String executeType) {
    if (wasStatementLogged || !DBG) {
      return;
    }
    wasStatementLogged = true;

    long executeTimeNanos = System.nanoTime() - statementStartTimeNanos;
    if (log.isDebugEnabled() || executeTimeNanos > LOG_IF_LONGER_TIME_NANOS) {
      StringBuilder sb = new StringBuilder();
      sb.append(
          String.format(
              Locale.US,
              "%s complete in %dms", executeType, executeTimeNanos * 1000000L));
      sb.append(System.lineSeparator());
      sb.append(sql);
      sb.append(System.lineSeparator());
      for (Object obj : parameters) {
        sb.append(String.format("? = %s", obj.toString()));
        sb.append(System.lineSeparator());
      }

      if (executeTimeNanos > LOG_IF_LONGER_TIME_NANOS) {
        log.warning(sb.toString());
      } else {
        log.debug(sb.toString());
      }
    }
  }

  @Override
  public void close() throws SQLException {
    logStatement("close");

    for (SqlResult res : results) {
      res.close();
    }
    stmt.close();
    if (autoCloseConnection) {
      conn.close();
    }
  }
}
